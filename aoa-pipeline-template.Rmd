---
title: "AoA prediction template"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
options(dplyr.summarise.inform = FALSE)

# load libraries
library(tidyverse)
library(glue)
library(wordbankr)
library(childesr)
library(broom)
library(car)
library(jglmm)
library(modelr)

# load functions
walk(list.files("scripts", pattern = "*.R$", full.names = TRUE), source)
```

This template provides the structure for how to fit age of acquisition (AoA) prediction models, using data and scripts in this repository.

The general steps are:
- loading the provided CDI data and predictor data
- adding your predictor(s) to the provided predictor data
- using the functions in `scripts/prep_data.R` to prepare the data for modeling
- using the functions in `scripts/fit_models.R` to fit models and extract information from them


# Wordbank data

Loading cached Wordbank data for English:
```{r}
eng_wb_data <- readRDS("data/wordbank/english_(american).rds")
eng_wb_data
```

Loading cached Wordbank data for multiple languages:
```{r}
target_langs <- c("Croatian", "Danish", "English (American)", "Norwegian", "Russian", "Turkish", "French (French)", "Spanish (Mexican)", "Italian", "Swedish",  "English (Australian)", "German", "English (British)","French (Quebecois)")

#Issues:#Portuguese (European) Spanish (European)" give NA in unilemmas 

wb_data <- map_df(target_langs, function(lang) {
  message(glue("Loading data for {lang}..."))
  norm_lang <- normalize_language(lang)
  readRDS(glue("data/wordbank/{norm_lang}.rds"))
})

```

Creating saved Wordbank data for English:
```{r, eval=FALSE}
create_wb_data("Portuguese (European)")
```

Creating saved Wordbank data for many languages:
```{r, eval=FALSE}
walk(target_langs, create_wb_data)
```

Creating saved Wordbank data one step at a time (potentially making changes between steps):
```{r, eval=FALSE}
eng_wg <- create_inst_data("Portuguese (European)", "WG")
eng_ws <- create_inst_data("Portuguese (European)", "WS")
eng_wg_summary <- collapse_inst_data(eng_wg)
eng_ws_summary <- collapse_inst_data(eng_ws)
eng_comb_summary <- combine_form_data(list(eng_wg_summary, eng_ws_summary))
```


# Predictors

Merge in the by-concept predictors (babiness, concreteness, etc) to the unilemmas and the by word predictors (phonemes) to the words/definitions.

```{r}
uni_lemmas <- get_uni_lemmas(wb_data)
uni_lemma_map <- build_uni_lemma_map(uni_lemmas)


```

```{r, eval=FALSE}

babiness_map <- c(word = "word", babiness = "babyAVG")
babiness <- uni_lemmas |> map_predictor("babiness", babiness_map)

valence_map <- c(word = "Word", valence = "V.Mean.Sum", arousal = "A.Mean.Sum")
valence <- uni_lemmas |> map_predictor("valence", valence_map)

concreteness_map <- c(word = "Word", concreteness = "Conc.M")
concreteness <- uni_lemmas |> map_predictor("concreteness", concreteness_map)

# TODO: requires espeak
# http://espeak.sourceforge.net

phonemes <- uni_lemmas |> map_phonemes()
# left_join(phonemes, by = c("language", "uni_lemma")) |>
```

Loading cached CHILDES data for English:
```{r}
eng_childes <- readRDS("data/childes/uni_metrics_english_(american).rds")
eng_childes
```

Loading cached CHILDES data for multiple languages:
```{r}

childes_metrics <- map_df(target_langs, function(lang) {
  message(glue("Loading CHILDES data for {lang}..."))
  norm_lang <- normalize_language(lang)
  readRDS(glue("data/childes/uni_metrics_{norm_lang}.rds"))
})

#Normalized smoothed frequencies
#the output has: 
#1. raw counts of uni_lemmas (count, count_first, count_last, count_solo)
#2. sum count of whole CHILDES corpus (sumcount, sumcount_first, sumcount_last, sumcount_solo)
#3. freq_raw is the raw frequency (dividing count / sumcount)

childes_metrics<-map_df(target_langs, prepare_cdata, childes_metrics, uni_lemmas)

```

Creating saved CHILDES data for English, potentially changing which metrics are computed and/or arguments that are passed to `childesr`:
```{r, eval=FALSE}
metric_funs <- list(compute_count, compute_mlu, compute_positions,
                    compute_length_char, compute_length_phon)
corpus_args <- list(corpus = NULL, role = NULL, role_exclude = "Target_Child",
                    age = NULL, sex = NULL, part_of_speech = NULL, token = "*")

get_childes_metrics("Portuguese (European)", metric_funs, corpus_args)
get_uni_lemma_metrics("Portuguese (European)", uni_lemma_map)
```

Creating saved CHILDES data for many languages:
```{r, eval=FALSE}
walk(target_langs, get_childes_metrics, metric_funs, corpus_args)
walk(target_langs, get_uni_lemma_metrics, uni_lemma_map)
```

Normalize frequency:
```{r}
#the output has: 
#1. raw counts of uni_lemmas (count, count_first, count_last, count_solo)
#2. sum count of whole CHILDES corpus (sumcount, sumcount_first, sumcount_last, sumcount_solo)
#3. freq_raw is the raw frequency (dividing count / sumcount)

childes_metrics <- normalize_frequency(childes_metrics)  

# residualize frequency out of final and solo frequencies
childes_metrics$final_frequency <- do_residualization(childes_metrics$final_frequency, childes_metrics$frequency)
childes_metrics$solo_frequency  <- do_residualization(childes_metrics$solo_frequency, childes_metrics$frequency)
childes_metrics$first_frequency  <- do_residualization(childes_metrics$first_frequency, childes_metrics$frequency)
```

Combine mapped predictors and CHILDES predictors:
```{r}
uni_joined <- uni_lemmas |>
  #left_join(babiness, by = c("language", "uni_lemma")) |>
  left_join(valence, by = c("language", "uni_lemma")) |>
  left_join(concreteness, by = c("language", "uni_lemma")) |>
  left_join(childes_metrics, by = c("language", "uni_lemma"))

#uni_joined <- uni_joined %>% filter(!is.na(frequency))

```

```{r impute}
prepped_data <- uni_joined |>
  # select out just the by lexical item data
  unnest(cols = "items") |>
  # select(-c(age, num_true, total, form, item_id)) |>
  distinct() |>
  # pull out categories from classes
  mutate(lexical_category = if_else(str_detect(lexical_class, ","), "other",
                                    lexical_class),
         # collapse v, adj, adv into one category
         lexical_category = lexical_category |> as_factor() |>
           suppressWarnings(
             fct_collapse("predicates" = c("verbs", "adjectives", "adverbs"))
             )) |>
  select(-lexical_class)

pred_sources <- list(
  c("frequency","final_frequency", "first_frequency", "solo_frequency"),
  c("concreteness", "babiness", "valence"),
  c("mlu"),
  c("length_char"),
  c("n_tokens"))
#  c("length_char", "n_tokens"))

imputed_data <- prepped_data |> do_full_imputation(pred_sources, 20)

```


# Model fitting

aoa lm model:
```{r aoa-lm}

wb_data <- wb_data |>
  mutate(num_false = total - num_true,
         prop = num_true / total) |>
  select(language, measure, uni_lemma, prop, num_true,age, num_false, total, items) %>%
         unique()

aoas <- wb_data |>
  group_by(language, measure) |>
  nest() |>
  mutate(aoa = map(data, get_aoas, max_steps = 400)) |>
  select(-data) |>
  unnest(cols = c(aoa))

word_values <- aoas |>
  left_join(imputed_data |>
              select(-data) |>
              unnest(cols = c(imputed)), 
            by = c("language", "uni_lemma")) 


joined_data <- wb_data |>
  left_join(word_values, by = c("language", "measure", "uni_lemma"))

#preds=list(c("frequency","mlu","final_frequency","valence", "concreteness", "babiness", "first_frequency", "solo_frequency", "length_char", "n_tokens"))

#preds_ind=list(c("frequency"),c("mlu"),c("final_frequency"), c("first_frequency"), c("solo_frequency"), c("length_char"), c("n_tokens"))

fitted_aoa_models <- map_df(preds, fit_models, joined_data)
saveRDS(fitted_aoa_models, "data/fitted_aoa_models_whole.rds")

fitted_aoa_models_reliability <- map_df(preds_ind, fit_models, joined_data, lex_effects=FALSE)
saveRDS(fitted_aoa_models_reliability, "data/fitted_aoa_models_reliability.rds")

```


age glmer model:
```{r age-glmer}
## TODO: fix fit_models; currently failing in Julia
#fitted_age_models <- fit_models(joined_data, predictors, full = TRUE)
```

Cross-validation:
```{r}
# for simple cv result extraction
loo_df <- word_values |>
  group_nest() |>
  mutate(loo_data = map(data, crossv_loo),
         loo_models = map(data, fit_cv_models, list(make_effs_formula(predictors, FALSE, TRUE))),
         loo_preds = map2(loo_models, data, get_cv_preds),
         cv_results = map(loo_preds, get_cv_results))
cv_results <- loo_df |>
  select(c(language, measure, cv_results)) |>
  unnest(cols = c(cv_results))
```


```{r}
cv_model <- function(preds, loo_df, lang, meas, w_v){
 loo_models <- fit_cv_models(w_v, list(make_effs_formula(preds, FALSE, TRUE)), loo_df)
 loo_preds <- get_cv_preds(loo_models, w_v)
 cv_results <- get_cv_results(loo_preds) 
 cv <-cv_results %>%
 select(mean_abs_dev, ci_mad_min, ci_mad_max) %>% 
 mutate(language=lang, measure=meas, pr=list(preds))
 return(cv)
}


main_cvpred <- function(w_v){
targetl<- unique(w_v$language) 
cv_df<-function(lang, meas){
 loo_df <- crossv_loo(ungroup(w_v))
 m<-map_df(preds, cv_model, loo_df, lang, meas, w_v)
 return(m)
} 
if (length(targetl) != 0){
r<- map_df(targetl, cv_df, meas)
return(r)
}
}

cv<- function(lang, word_values, meas){
# if (lang=="English (American)"){
#    word_values<- word_values %>% filter(!(language=="English (American)" & #uni_lemma=="hi")) #crazy value
#  }
cv_lang <-  main_cvpred(word_values %>% filter(language==lang, measure==meas)) %>%
  mutate(measure=meas) 
return(cv_lang)
}

#####apply cross-validation
cv_across_lang <- map_df(target_langs, cv, word_values, "produces") %>% 
  rbind(map_df(target_langs_understand, cv, word_values, "understands"))
saveRDS(cv_across_lang, "data/cv_across_lang.rds")


cv_model_lex <- function(preds, loo_df, lang, meas){
 loo_models <- fit_cv_models(word_values, list(make_effs_formula(preds, FALSE, TRUE)), loo_df)
 loo_preds <- get_cv_preds(loo_models, word_values) %>%
  mutate(language=lang, measure=meas, pr=list(preds))
 return(loo_preds)
}

main_cvpredlex <- function(lang, meas){
word_v<- word_values %>%  filter(measure ==meas, language==lang)
targetl<- unique(word_v$language) 
cv_df_l<-function(lang, meas){
 word_values<- word_values %>%  filter(measure ==meas, language==lang)
 loo_df <- crossv_loo(ungroup(word_values))
 m<-map_df(preds, cv_model_lex, loo_df, lang, meas)
 return(m)
} 
if (length(targetl) != 0){
r<- map_df(targetl, cv_df_l, meas)
return(r)
}
}

####check lexical category distribution english
eng_cv_across_lang_lex <- map_df("English (American)", main_cvpredlex, meas="understands")
eng_across_lang_lex_desc <-  head(arrange(eng_cv_across_lang_lex, desc(abs_dev)), 50) 

```

Evaluate collinearity between predictors using variance inflation factor (VIF) of a set of predictors (pred). For a single language:
```{r vif}
eng_joined_data <- word_values |> filter(language == "English (American)")
preds <- c("frequency", "concreteness", "mlu")
vif_scores <- get_vif_bylang_bymeasure(eng_joined_data, preds)
```

Evaluate collinearity between predictors using variance inflation factor (VIF) of a set of predictors (pred). For a set of languages:
```{r vif}
preds <- c("frequency", "concreteness", "mlu")
vif_scores <- get_vif_bylang_bymeasure(word_values, preds)
```

```{r plots}

#####plots
lang_coefs <- fitted_aoa_models %>%
  unnest(coeffs) %>%
  mutate(signif=ifelse(p.value<0.05, TRUE, FALSE)) %>%
  filter(term %in% predictors) 

lang_coefs$term = factor(lang_coefs$term, levels = c("frequency", "solo_frequency", "first_frequency", "final_frequency", "mlu", "length_char", "n_tokens",
                            "babiness", "concreteness", "valence"))

lang_coefs$language = factor(lang_coefs$language, levels=c("English (American)","English (British)","English (Australian)",   "German", "French (French)", "French (Quebecois)", "Spanish (Mexican)","Swedish",  "Italian", "Croatian", "Danish",  "Norwegian",  "Turkish","Russian"))



pdf(file = "data/rus_coefs.pdf",  width = 6,  height = 4) 
russian_coefs <- lang_coefs %>% filter(language =="Russian", measure =="produces")
coefs_by_lang(russian_coefs)
dev.off()

pdf(file = "data/eng_coefs.pdf",   width = 5,  height = 3) 
coefs_by_lang(lang_coefs %>% filter(language=="English (American)"))
dev.off()

pdf(file = "data/lang_coefs.pdf",    width = 20, height = 5) 
coefs_by_lang(lang_coefs %>% filter(!language =="Russian"))
dev.off()

pdf(file = "data/pred_coefs.pdf",  width = 8,   height = 5) 
coefs_by_pred(lang_coefs%>% filter(!language =="Russian"))
dev.off()

pdf(file = "data/cv_lang.pdf",    width = 8,  height = 4) 
cv_dev_lang(cv_across_lang%>% filter(!language=="English (British)", !language=="Russian"))
dev.off()

pdf(file = "data/dev_words_eng_compre.pdf", width = 7, height = 5) 
dev_words(eng_across_lang_lex_desc)
dev.off()

pdf(file = "data/aoa_mad_lex_eng_understands.pdf", width = 7, height = 5) 
aoa_mad_lex_cat(eng_across_lang_lex_desc, "English (American)", "understands", wb_data, preds)  
dev.off()

pdf(file = "data/reliability_plot.pdf", width = 12, height = 3.5)
relia_plot(dfinal, lang_list)
dev.off()
```

